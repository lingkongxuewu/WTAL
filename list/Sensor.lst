C51 COMPILER V9.01   SENSOR                                                                06/25/2018 15:28:31 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE SENSOR
OBJECT MODULE PLACED IN .\obj\Sensor.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE scr\Sensor.c OPTIMIZE(9,SIZE) BROWSE DEBUG OBJECTEXTEND PRINT(.\list\Sensor
                    -.lst) OBJECT(.\obj\Sensor.obj)

line level    source

   1          /*--------------------------------文*件*信*息-----------------------------
   2          * 文件名：  Sensor.c
   3          * 版　本：  v1.0
   4          * 描  述：  100T双轴 整合后的版本
   5          * 创建人：  
   6          * 日  期：  
   7          --------------------------------------------------------------------------
   8          *当前版本:      v1.0
   9          *修 改 人:
  10          *日　  期:
  11          ----------------------------------修改履历--------------------------------
  12          1、
  13          2、
  14          3、
  15          4、
  16          ------------------------------------------------------------------------*/
  17          #define __SENSOR_C__
  18          #include "_Include.h"
  19          
  20          //-------------define-----------------
  21          
  22          static int8u    xdata  filtercnt; //滤波系数
  23          //***********************************************************************/
  24          // *功    能：数据初始化
  25          // *入    口：p_sn,sensor结构体指针(X,Y);p_tempcal,temp_calib结构体指针(温补);
  26          //            p_angcal,ang_calib结构体指针(角度标定)
  27          // *出    口：
  28          // *备    注：
  29          // *函数性质：
  30          //***********************************************************************/
  31          static void Sn_DataInit(struct sensor *p_sn, struct ang_calib *p_angcal)
  32          {
  33   1              p_sn->val=0;     //原始值
  34   1              p_sn->ftval=0;   //滤波之后的值
  35   1              p_sn->ftval_f=0;
  36   1              p_sn->ang=0;    //
  37   1              p_sn->angcal=p_angcal;    //指向ang_xcal Ang_Ycal
  38   1      }
  39          
  40          //***********************************************************************/
  41          // *功    能：传感器值滤波
  42          // *入    口：p_sn,sensor结构体指针(X,Y);val,新值;ftcnt，一阶滤波系数
  43          // *出    口：
  44          // *备    注：ADC滤波后的值
  45          // *函数性质：
  46          //***********************************************************************/
  47          static void SnFilter(struct sensor *p_sn, int16u val, int8u ftcnt)
  48          {
  49   1          if(ValInRange(p_sn->ftval,val,(int16u)FILTER_SUBB))    //限幅滤波
  50   1          {
  51   2              p_sn->ftval_f=Filter_1st(p_sn->ftval_f,val,ftcnt);     //一阶滤波
  52   2              
  53   2              p_sn->ftval=(int16u)(p_sn->ftval_f+0.5);
  54   2              
C51 COMPILER V9.01   SENSOR                                                                06/25/2018 15:28:31 PAGE 2   

  55   2          }
  56   1          else
  57   1              p_sn->ftval  =val;    //变化幅度较大，直接写入新值
  58   1              p_sn->ftval_f=val;
  59   1      }
  60          
  61          
  62          
  63          //***********************************************************************/
  64          // *功    能：获取标定后的角度值
  65          // *入    口：p_sn,sensor结构体指针(X,Y);val,角度的ADC值
  66          // *出    口：角度正弦值
  67          // *备    注：ang=k*ang_adc+a;
  68          // *函数性质：
  69          //***********************************************************************/
  70          static float GetAngCalcVal(struct sensor *p_sn, int16u val)
  71          {
  72   1          int8u i;
  73   1          float tmp;
  74   1      
  75   1          for(i=0;i<(p_sn->angcal->calcnt-2);i++)
  76   1          {
  77   2              if(val<(p_sn->angcal->adcarr[i+1]))    //查找当前角度ADC值在角度标定模块中ADC值数组中的位置
  78   2                  break;
  79   2          }
  80   1          tmp = p_sn->angcal->prm_k[i]*val + p_sn->angcal->prm_a[i];    //获取相应的K,A值，并计算
  81   1          return tmp;
  82   1      }
  83          
  84          //***********************************************************************/
  85          // *功    能：角度计算
  86          // *入    口：p_sn,sensor结构体指针(X,Y);
  87          // *出    口：
  88          // *备    注：
  89          // *函数性质：
  90          //***********************************************************************/
  91          static void Ang_Calc(struct sensor *p_sn)
  92          {
  93   1          float ang;
  94   1          ang=GetAngCalcVal(p_sn,p_sn->ftval);       //角度标定后的角度正弦值
  95   1          if(ang>=1)
  96   1              p_sn->ang=90000;
  97   1          else if(ang<=-1)
  98   1              p_sn->ang=-90000;
  99   1          else
 100   1          {
 101   2              ang=asin(ang);
 102   2              ang=ang/PI*180000;
 103   2              p_sn->ang=ang;
 104   2          }
 105   1      }
 106          
 107          //***********************************************************************/
 108          // *功    能：加速度传感器X数据初始化
 109          // *备    注：ang_xcal，角度标定模块
 110          //***********************************************************************/
 111          void SnXDataInit(void)
 112          {
 113   1          Sn_DataInit(&accel_x,&Ang_Xcal);
 114   1      }
 115          void SnYDataInit(void)
 116          {
C51 COMPILER V9.01   SENSOR                                                                06/25/2018 15:28:31 PAGE 3   

 117   1          Sn_DataInit(&accel_y,&Ang_Ycal);    //加速度传感器Y数据初始化
 118   1      }
 119          void SnXFilter(int16u val, int16u ftcnt)
 120          {
 121   1          SnFilter(&accel_x,val,ftcnt);    //X滤波
 122   1      }
 123          void SnYFilter(int16u val, int16u ftcnt)
 124          {
 125   1          SnFilter(&accel_y,val,ftcnt);    //y滤波
 126   1      }
 127          
 128          void AngXCalc(void)
 129          {
 130   1          Ang_Calc(&accel_x);    //X角度计算
 131   1      }
 132          void AngYCalc(void)
 133          {
 134   1          Ang_Calc(&accel_y);    //Y角度计算
 135   1      }
 136          //***********************************************************************/
 137          // *功    能：传感器结构体初始化
 138          // *入    口：
 139          // *出    口：
 140          // *备    注：
 141          // *函数性质：
 142          //***********************************************************************/
 143          void SnInit(void)
 144          {
 145   1          CalibInit();            //校准模块初始化
 146   1          SetFilterCnt(20);        //
 147   1          accel_x.DataInit=SnXDataInit;
 148   1          accel_x.Filter=SnXFilter;
 149   1          accel_x.AngCalc=AngXCalc;
 150   1          accel_x.DataInit();
 151   1      
 152   1          accel_y.DataInit=SnYDataInit;
 153   1          accel_y.Filter=SnYFilter;
 154   1          accel_y.AngCalc=AngYCalc;
 155   1          accel_y.DataInit();
 156   1      }
 157          
 158          //***********************************************************************/
 159          // *功    能：获取角度的AD值（窗口滤波后），进行一阶滤波和温度补偿 ，算出角度值
 160          // *入    口：
 161          // *出    口：
 162          // *备    注：
 163          // *函数性质：
 164          //***********************************************************************/
 165          void SnProc(void)
 166          {
 167   1          {
 168   2          if(AdcEndTag==0)
 169   2              return;
 170   2          AdcEndTag=0;
 171   2      
 172   2          switch(AdcEndId)
 173   2          {
 174   3              case 0:
 175   3                   accel_x.val=Adc_GetXVal();                                             //读取X轴的角度AD值 （
             -窗口滤波后）
 176   3                   accel_x.Filter((accel_x.val),filtercnt);                               //一阶滤波
 177   3      //             accel_x.oftval=(int16u)((int16s)accel_x.ftval+
C51 COMPILER V9.01   SENSOR                                                                06/25/2018 15:28:31 PAGE 4   

 178   3      //                                            accel_x.GetTempOffset(Get_McuTemp()));  //温度补尝
 179   3                   accel_x.AngCalc();                                                      //计算角度（温补后）
 180   3                      break;
 181   3      
 182   3              case 1:
 183   3                  accel_y.val=Adc_GetYVal();
 184   3                  accel_y.Filter((accel_y.val),filtercnt);                                //一阶滤波
 185   3      //            accel_y.oftval=(int16u)((int16s)accel_y.ftval+
 186   3      //                                    accel_y.GetTempOffset(Get_McuTemp()));          //温度补尝
 187   3                  accel_y.AngCalc();
 188   3              default:
 189   3                  break;
 190   3          }
 191   2          ADC0CN |= 0x10;
 192   2       }
 193   1      }
 194          
 195          //***********************************************************************/
 196          // *功    能：获取一阶滤波系数
 197          // *入    口：
 198          // *出    口：一阶滤波系数
 199          // *备    注：
 200          // *函数性质：
 201          //***********************************************************************/
 202          int8u GetFilterCnt(void)
 203          {
 204   1          return filtercnt;
 205   1      }
 206          //***********************************************************************/
 207          // *功    能：设置一阶滤波系数
 208          // *入    口：
 209          // *出    口：
 210          // *备    注：
 211          // *函数性质：
 212          //***********************************************************************/
 213          void SetFilterCnt(int8u cnt)
 214          {
 215   1          filtercnt=cnt;
 216   1      }
 217          
 218          //***********************************************************************/
 219          // *功    能：获取当前温度
 220          // *入    口：
 221          // *出    口：
 222          // *备    注：
 223          // *函数性质：
 224          //***********************************************************************/
 225          int16u Get_McuTemp(void)
 226          {
 227   1      
 228   1              return(Adc_GetTemp());      //MCU所测的温度值
 229   1      }
 230          
 231          //***********************************************************************/
 232          // *功    能：获取X轴一阶滤波后的值
 233          // *入    口：
 234          // *出    口：
 235          // *备    注：
 236          // *函数性质：
 237          //***********************************************************************/
 238          int16u GetXFtVal(void)
 239          {
C51 COMPILER V9.01   SENSOR                                                                06/25/2018 15:28:31 PAGE 5   

 240   1          return (accel_x.ftval);
 241   1      }
 242          
 243          //***********************************************************************/
 244          // *功    能：获取Y轴一阶滤波后的值
 245          // *入    口：
 246          // *出    口：
 247          // *备    注：
 248          // *函数性质：
 249          //***********************************************************************/
 250          int16u GetYFtVal(void)
 251          {
 252   1          return (accel_y.ftval);
 253   1      }
 254          
 255          ////***********************************************************************/
 256          //// *功    能：获取X轴温补后的值
 257          //// *入    口：
 258          //// *出    口：
 259          //// *备    注：
 260          //// *函数性质：
 261          ////***********************************************************************/
 262          //int16s GetXOftVal(void)
 263          //{
 264          //    return (accel_x.oftval);
 265          //}
 266          
 267          ////***********************************************************************/
 268          //// *功    能：获取Y轴温补后的值
 269          //// *入    口：
 270          //// *出    口：
 271          //// *备    注：
 272          //// *函数性质：
 273          ////***********************************************************************/
 274          //int16s GetYOftVal(void)
 275          //{
 276          //    return (accel_y.oftval);
 277          //}
 278          
 279          //***********************************************************************/
 280          // *功    能：获取X轴角度值
 281          // *入    口：
 282          // *出    口：
 283          // *备    注：
 284          // *函数性质：
 285          //***********************************************************************/
 286          int32s GetXAng(void)
 287          {
 288   1          return (accel_x.ang);
 289   1      }
 290          
 291          //***********************************************************************/
 292          // *功    能：获取Y轴角度值
 293          // *入    口：
 294          // *出    口：
 295          // *备    注：
 296          // *函数性质：
 297          //***********************************************************************/
 298          int32s GetYAng(void)
 299          {
 300   1          return (accel_y.ang);
 301   1      }
C51 COMPILER V9.01   SENSOR                                                                06/25/2018 15:28:31 PAGE 6   



MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    781    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     49    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      25
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
